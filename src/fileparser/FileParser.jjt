/**
 * JJTree template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  LOOKAHEAD= 1000;  NODE_FACTORY = "NodeFactory";}PARSER_BEGIN(FileParser)package fileparser;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.io.FileOutputStream;
import java.io.PrintStream;

import faops.FA;

import java.util.ArrayList;
import java.util.Arrays;public class FileParser{  public static void main(String args []) throws FileNotFoundException  {    System.out.println("Reading from standard input...");
    SimpleNode n1;
    SimpleNode n2;
    FileParser fp = new FileParser(new FileInputStream(new File(FileParser.class.getResource("product1.dot").getPath())));
    try {
		n1 = FileParser.Start();
	} catch (ParseException e1) {
		e1.printStackTrace();
		return;
	}
    FileParser.ReInit(new FileInputStream(new File(FileParser.class.getResource("product2.dot").getPath())));
    try {
		n2 = FileParser.Start();
	} catch (ParseException e1) {
		// TODO Auto-generated catch block
		e1.printStackTrace();
		return;
	}
    try
    {
      n1.dump("");
      n2.dump("");
      FA fa1 = toFa(n1);
      FA fa2 = toFa(n2);
      if (fa1 != null && fa2 != null)
      {
        //fa.toDFA().toDot(new PrintStream(new FileOutputStream("src/fileparser/dfa.dot", false)));
    	FA fa = FA.product(null, fa1,fa2);
    	fa.toDot(new PrintStream(new FileOutputStream("src/fileparser/product.dot", false)));
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        while (true)
        {
          System.out.println("Input:");
          String s = reader.readLine();
          if (fa.process(s.split(""))) System.out.println("yes");
          else System.out.println("no");
        }
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }  }  public static FA toFa(SimpleNode root)  {    FA out = new FA();    ArrayList < String > stateNames = new ArrayList < String > ();    try    {      for (int i = 0; i < root.jjtGetNumChildren(); i++)      {        faRead(root.jjtGetChild(i), out, stateNames);      }    }    catch (Exception e)    {      e.printStackTrace();      return null;    }
    out.computeIsDFA();    return out;  }  public static void faRead(Node node, FA fa, ArrayList < String > stateNames) throws Exception  {    switch (((SimpleNode) node).id)    {      case FileParserTreeConstants.JJTSTATE : StateNode stateNode = (StateNode) node;      if (stateNode.isStartState)      {        int index = stateNames.indexOf(stateNode.name);        if (index == - 1) throw new Exception("Start State does not exist");        fa.setInitialState(index);      }      else      {        if (stateNames.contains(stateNode.name)) throw new Exception("State " + stateNode.name + " is repeated");        fa.incNumStates();        if (stateNode.isFinalState) fa.addFinalState(stateNames.size());        stateNames.add(stateNode.name);      }      break;      case FileParserTreeConstants.JJTTRANSITION :       TransitionNode tNode = (TransitionNode) node;      int srcindex = stateNames.indexOf(tNode.src);      if (srcindex == - 1) throw new Exception("Source State" + tNode.src + "does not exist");      int dstindex = stateNames.indexOf(tNode.dst);      if (dstindex == - 1) throw new Exception("Destination State " + tNode.dst + " does not exist");      for (String symbol : tNode.symbols)      {        fa.addTransition(symbol, srcindex, dstindex);      }      break;    }    for (int i = 0; i < node.jjtGetNumChildren(); i++)    {      faRead(node.jjtGetChild(i), fa, stateNames);    }  }}PARSER_END(FileParser)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* LITERALS */{  < DIGRAPH : "digraph" >| < RANKDIR : "rankdir" >| < START : "start" >| < SHAPE : "shape" >| < COLOR : "color" >| < FONTCOLOR : "fontcolor" >| < POINT : "point" >| < WHITE : "white" >| < BLACK : "black" >| < LABEL : "label" >| < CIRCLE : "circle" >| < DOUBLECIRCLE : "doublecircle" >| < NODE : "node" >| < LR : "LR" >| < OPEN : "[" >| < CLOSE : "]" >| < ENDSTMT : ";" >| < ID : ([ "0"-"9", "A"-"Z", "a"-"z", "_", "!" ])+ >}SimpleNode Start() :{}{  < DIGRAPH > (< ID >)? "{"  (    RankDir()  )?  StartDecl()  (    StateDecl()  )+  #States StartState()(  TransitionNode())+#Transitions "}" < EOF >{  return jjtThis;}}void RankDir() #void :{}{  < RANKDIR > "=" < LR > ";"}void StartDecl() #void :{}{  //< START >
  < NODE > < OPEN > < SHAPE > "=" < POINT > "," < COLOR > "=" < WHITE > "," < FONTCOLOR > "=" < WHITE > < CLOSE > < ENDSTMT > < START > < ENDSTMT >}void StateDecl() #State :{  Token stateName;}{  //(< NODE >  < OPEN > < SHAPE> "=" < DOUBLECIRCLE > "," < COLOR >  "=" < BLACK > "," < FONTCOLOR > "=" < BLACK > < CLOSE > < ENDSTMT > stateName = < ID > { jjtThis.name = stateName.image; } < ENDSTMT > #FinalState)
  //|(< NODE > < OPEN > < SHAPE > "=" < CIRCLE > < CLOSE > < ENDSTMT > stateName = < ID > { jjtThis.name = stateName.image; } < ENDSTMT > #NonFinalState)
  < NODE > < OPEN > < SHAPE > "="  (    (      < DOUBLECIRCLE >      {        ((StateNode) jjtThis).isFinalState = true;      }    )  | (< CIRCLE >)  )  "," < COLOR > "=" < BLACK > "," < FONTCOLOR > "=" < BLACK > < CLOSE > < ENDSTMT > stateName = < ID >  {    ((StateNode) jjtThis).name = stateName.image;  }  < ENDSTMT >}void StartState() #State :{  Token startStatename;}{  < START > "->" startStatename = < ID >  {    ((StateNode) jjtThis).name = startStatename.image;  }  < ENDSTMT >  {    ((StateNode) jjtThis).isStartState = true;  }}void TransitionNode() #Transition :{  Token src;  Token dst;  Token transition;}{  src = < ID >  {    ((TransitionNode) jjtThis).src = src.image;  }  "->" dst = < ID >  {    ((TransitionNode) jjtThis).dst = dst.image;  }  < OPEN > < LABEL > "=" "\""  (    transition = < ID >    {      ((TransitionNode) jjtThis).addTransition(transition.image);    }    ","  )*  transition = < ID >  {    ((TransitionNode) jjtThis).addTransition(transition.image);  }  "\"" < CLOSE > < ENDSTMT >}